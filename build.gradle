import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

plugins {
	id 'java'
	id 'antlr'
	id 'idea'
	id 'checkstyle'
	id 'com.diffplug.spotless' version '6.21.0'
}

group = 'org.daiitech'
version = '0.0.1-SNAPSHOT'

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(17)
	}
}

repositories {
	mavenCentral()
}

dependencies {
	antlr "org.antlr:antlr4:4.9.3"
	implementation "org.antlr:antlr4-runtime:4.9.3"
	testImplementation(platform('org.junit:junit-bom:5.7.0'))
	testImplementation('org.junit.jupiter:junit-jupiter')
	checkstyle 'com.puppycrawl.tools:checkstyle:10.0'
	implementation 'info.picocli:picocli:4.7.6'
	implementation 'org.jline:jline:3.23.0'
	implementation 'org.jline:jline-terminal-jansi:3.28.0'
}

tasks.withType(JavaCompile).configureEach  {
	options.encoding = 'UTF-8'
}

tasks.withType(ProcessResources).configureEach  {
	filteringCharset = 'UTF-8'
}

generateGrammarSource {
	maxHeapSize = "128m"
	arguments += ['-encoding', 'UTF-8','-package', 'org.daiitech.naftah.parser', '-visitor', '-no-listener']
}

compileJava.dependsOn generateGrammarSource

sourceSets {
	generated {
		java.srcDir 'generated-src/antlr/main/'
	}
}

compileJava.source sourceSets.generated.java, sourceSets.main.java

clean {
	delete "generated-src"
}

idea {
	module {
		sourceDirs += file("generated-src/antlr/main/")
	}
}

tasks.register('extractLexerLiterals') {
	description = 'Extracts all literal strings from lexer grammar rules.'

	def lexerFile = file('src/main/antlr/NaftahLexer.g4')
	def outputFile = file("$buildDir/libs/lexer-literals")

	def tokensFile =  file("$buildDir/libs/tokens-symbols.properties")

	doLast {
		// literals processing
		def literalsPattern = ~/'([^']+)'/
		def literals = []
		// tokens list processing
		def tokensPattern = ~/^(\w+)\s*:\s*((?:'[^']+'\s*\|\s*)*'[^']+')\s*;$/
		def skipPatterns = [
				~/^\s*fragment\s*.*/,
				~/.*\s*skip\s*.*/,
				~/^\s*WS\s*:\s*.*/,
				~/^\s*LINE_COMMENT\s*:\s*.*/,
				~/^\s*BLOCK_COMMENT\s*:\s*.*/,
				~/^\s*QuotationMark\s*:\s*.*/,
				~/^\s*DoubleQuotationMark\s*:\s*.*/,
				~/^\s*DoubleQuotationMarkLeft\s*:\s*.*/,
				~/^\s*DoubleQuotationMarkRight\s*:\s*.*/,
				~/^\s*\/\/.*$/,      // skip comment lines starting with //
				~/^\s*$/,            // skip empty lines
		]

		def literalPatterns = [
				~/^\s*NUMBER\s*:\s*.*/,
				~/^\s*CHARACTER\s*:\s*.*/,
				~/^\s*STRING\s*:\s*.*/,
				~/^\s*ID\s*:\s*.*/,
				~/^\s*PUNCTUATION\s*:\s*.*/
		]

		def literalTranslations = [
				"NUMBER"      : "Ø±Ù‚Ù…",
				"CHARACTER"   : "Ø­Ø±Ù",
				"STRING"      : "Ø³Ù„Ø³Ù„Ø©",
				"ID"          : "Ù…Ø¹Ø±Ù",
				"PUNCTUATION" : "ØªØ±Ù‚ÙŠÙ…"
		]
		def tokens = new Properties()

		lexerFile.withReader('UTF-8') { reader ->
			reader.eachLine { line ->
				// processing literals
				if (line.contains(":")) {
					literalsPattern.matcher(line).each { match ->
						literals << match[1]
					}
				}
				// processing tokens list
				// Skip lines matching any skip pattern
				boolean toSkip = skipPatterns.any { skipPattern -> line ==~ skipPattern }
				if (toSkip) {
					return
				}
				// Check for matching literal patterns and print Arabic translation
				boolean isLiteral = literalPatterns.any { literalPattern ->
					if (line ==~ literalPattern) {
						// Extract the key (e.g., NUMBER) from the line using regex
						def matcher = (line =~ /^\s*(\w+)\s*:/)
						if (matcher.find()) {
							def token = matcher.group(1)
							def symbol = literalTranslations[token]
							tokens.setProperty(token, "'${symbol}'")
						}
						return true
					}
					return false
				}

				if (!isLiteral) {

					def matcher = line =~ tokensPattern

					if (matcher.matches()) {
						def token = matcher[0][1]
						def tokensGroup = matcher[0][2]

						// Extract all quoted tokens
						def symbols = []
						(tokensGroup =~ literalsPattern).each { match ->
							symbols << match[0]
						}
						tokens.setProperty(token, symbols.join(", "))
					} else {
						def placeholderPattern = /^(\w+)\s*:\s*(.+);$/
						def placeholderMatcher = line =~ placeholderPattern
						if (placeholderMatcher.matches()) {
							def token = placeholderMatcher[0][1]
							def symbolsStr = placeholderMatcher[0][2].trim()

							// Split tokens by whitespace (since no pipes here)
							def symbolsList = symbolsStr.split(/\s+/).collect { "PLACEHOLDER(${it.trim()})" }

							// Remove single quotes if any (none here but safe)
							symbolsList = symbolsList.collect { it.replaceAll(/^'(.*)'$/, '$1') }

							tokens.setProperty(token, symbolsList.join(" "))
						}
					}
				}
			}
		}

		outputFile.parentFile.mkdirs()
		outputFile.withWriter('UTF-8') { writer ->
			literals.each { writer.writeLine(it) }
		}

		tokensFile.withOutputStream { stream ->
			tokens.store(stream, "tokens symbols list extracted from lexer.")
		}

		println "Extracted ${literals.size()} literals to ${outputFile}"
	}
}

tasks.register('writeResolvedJars') {
	description = 'Writes resolved JAR file names to build/libs/original-dependencies'

	doLast {
		def outputFile = file("$buildDir/libs/original-dependencies")
		outputFile.text = ""

		configurations.runtimeClasspath.resolvedConfiguration.resolvedArtifacts.each { artifact ->
			def jarName = artifact.file.name
			outputFile << jarName + "\n"
		}

		println "Dependencies written to: ${outputFile}"
	}
}

test {
	useJUnitPlatform()
	testLogging {
		events "passed", "skipped", "failed"
	}
}

checkstyle {
	toolVersion = '10.0'
	configFile = file("config/checkstyle/checkstyle.xml")
	ignoreFailures = false
	showViolations = true
}

spotless {
	java {
		// Using Google Java Format for formatting
		googleJavaFormat('1.17.0')
	}
}

// This task formats the code, but doesn't run on build by default
tasks.register('format') {
	group = 'formatting'
	description = 'Formats all Java source files.'

	dependsOn 'spotlessApply'
}
check.dependsOn checkstyleMain, checkstyleTest

// lint + format in one custom task
tasks.register('lintAndFormat') {
	group = 'verification'
	description = 'Run checkstyle lint and auto-format code.'

	dependsOn checkstyleMain, checkstyleTest, spotlessApply
}

tasks.register('generateReleasePropertiesFile') {
	doLast {
		def outputFile = new File("$buildDir/resources/main/META-INF/naftah-release-info.properties")

		// Create properties file and set properties
		outputFile.parentFile.mkdirs()  // Create the META-INF directory if it doesn't exist

		def buildDate = LocalDateTime.now()

		def date = buildDate.format(DateTimeFormatter.ofPattern('dd-MMM-yyyy'))
		def time = buildDate.format(DateTimeFormatter.ofPattern('hh:mm:ss'))

		outputFile.withWriter('utf-8') {
			it.write("""#
#  Licensed to the Apache Software Foundation (ASF) under one
#  or more contributor license agreements.  See the NOTICE file
#  distributed with this work for additional information
#  regarding copyright ownership.  The ASF licenses this file
#  to you under the Apache License, Version 2.0 (the
#  "License"); you may not use this file except in compliance
#  with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing,
#  software distributed under the License is distributed on an
#  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
#  KIND, either express or implied.  See the License for the
#  specific language governing permissions and limitations
#  under the License.
#

ImplementationVersion=${version}
BundleVersion=${version}
BuildDate=$date
BuildTime=$time
Class-Path= ${configurations.runtimeClasspath
					.files
					.collect { "lib/${it.name}" }
					.join(' ')
			}
""")
		}
	}
}

processResources.dependsOn generateReleasePropertiesFile

jar {
	manifest {
		attributes(
				'Main-Class': 'org.daiitech.naftah.Naftah',
				'Implementation-Title': 'NAFTAH',
				'Implementation-Version': project.version,
				'Implementation-Vendor': 'DaiiTech',
				'Built-By': System.getProperty('user.name'),
				'Built-Date':  LocalDateTime.now().format("yyyy-MM-dd'T'HH:mm"),
				// ðŸ‘‡ Class-Path attribute (relative paths to JARs in /lib/)
				'Class-Path': configurations.runtimeClasspath
						.files
						.collect { "lib/${it.name}" }
						.join(' ')
		)
	}
}

// Task to copy dependencies to /build/libs/lib/
tasks.register('copyDependencies', Copy) {
	from configurations.runtimeClasspath
	into "$buildDir/libs/lib"
}

jar.dependsOn processResources
jar.finalizedBy copyDependencies

tasks.register('fatJar', Jar) {
	archiveBaseName = "${project.name}-standalone"
	destinationDirectory.set(file("$buildDir/libs/"))
	manifest {
		attributes(
				'Main-Class': 'org.daiitech.naftah.Naftah',
				'Implementation-Title': 'NAFTAH',
				'Implementation-Version': project.version,
				'Implementation-Vendor': 'DaiiTech',
				'Built-By': System.getProperty('user.name'),
				'Built-Date':  LocalDateTime.now().format("yyyy-MM-dd'T'HH:mm")
		)
	}
	duplicatesStrategy = DuplicatesStrategy.EXCLUDE

	from {
		configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
	}
	with jar
}

tasks.register('baseDistZip', Zip) {
	// Set the name of the output zip file
	destinationDirectory.set(file("$buildDir/distributions"))
	archiveBaseName.set("${project.name}")

	from('.') {
		include 'INSTALL', 'LICENSE'
		into '.'
	}

	from('src/main/bin') {
		into 'bin'
	}

	from('learn-by-example') {
		into 'learn-by-example'
	}

	from("$buildDir/libs") {
		include 'lexer-literals', 'original-dependencies', 'tokens-symbols.properties'
		into 'lib'
	}

	// Avoid execution by itself
	enabled = false
}

tasks.register('dist', Zip) {
	dependsOn tasks.named("processResources"), tasks.named("copyDependencies"), tasks.named("jar"), tasks.named("extractLexerLiterals"), tasks.named("writeResolvedJars"), tasks.named("baseDistZip")

	duplicatesStrategy = DuplicatesStrategy.EXCLUDE

	archiveVersion.set("${project.version}-bin")

	with tasks.named("baseDistZip").get()

	from("$buildDir/libs") {
		include 'lib/*.jar', "${project.name}-${project.version}.jar"
		into 'lib'
	}

}

tasks.register('distStandalone', Zip) {
	dependsOn tasks.named("fatJar"), tasks.named("baseDistZip")

	duplicatesStrategy = DuplicatesStrategy.EXCLUDE

	archiveVersion.set("${project.version}-standalone-bin")

	with tasks.named("baseDistZip").get()

	from("$buildDir/libs") {
		include "${project.name}-standalone-${project.version}.jar"
		into 'lib'
	}
}
